   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"syscalls.c"
  23              	.Ltext0:
  24              		.file 1 "../src/syscalls.c"
 2348              		.align	1
 2349              		.global	_close_r
 2350              		.thumb
 2351              		.thumb_func
 2353              	_close_r:
 2354              	.LFB0:
   1:../src/syscalls.c **** /** \file syscalls.c
   2:../src/syscalls.c ****  * \brief System calls for newlib's libc
   3:../src/syscalls.c ****  * \details System calls for newlib's libc
   4:../src/syscalls.c ****  *
   5:../src/syscalls.c ****  * \author Freddie Chopin, http://www.freddiechopin.info/
   6:../src/syscalls.c ****  * \date 2010-11-11
   7:../src/syscalls.c ****  */
   8:../src/syscalls.c **** 
   9:../src/syscalls.c **** /******************************************************************************
  10:../src/syscalls.c **** * project: syscalls
  11:../src/syscalls.c **** * chip: (any)
  12:../src/syscalls.c **** * compiler: arm-none-eabi-gcc (Sourcery G++ Lite 2010q1-188) 4.4.1
  13:../src/syscalls.c **** *
  14:../src/syscalls.c **** * prefix: (none)
  15:../src/syscalls.c **** *
  16:../src/syscalls.c **** * available global functions:
  17:../src/syscalls.c **** * 	int _close_r(struct _reent *r, int file)
  18:../src/syscalls.c **** * 	int _execve_r(struct _reent *r, const char *path, char *const argv[], char *const envp[])
  19:../src/syscalls.c **** * 	void _exit(int status)
  20:../src/syscalls.c **** * 	pid_t _fork_r(struct _reent *r)
  21:../src/syscalls.c **** * 	int _fstat_r(struct _reent *r, int file, struct stat *st)
  22:../src/syscalls.c **** * 	pid_t _getpid_r(struct _reent *r)
  23:../src/syscalls.c **** * 	int _isatty_r(struct _reent *r, int file)
  24:../src/syscalls.c **** * 	int _kill_r(struct _reent *r, pid_t pid, int signal)
  25:../src/syscalls.c **** * 	int _link_r(struct _reent *r, const char *old, const char *new)
  26:../src/syscalls.c **** * 	off_t _lseek_r(struct _reent *r, int file, off_t offset, int whence)
  27:../src/syscalls.c **** * 	int _open_r(struct _reent *r, const char *pathname, int flags, int mode)
  28:../src/syscalls.c **** * 	ssize_t _read_r(struct _reent *r, int file, void *buf, size_t nbyte)
  29:../src/syscalls.c **** * 	caddr_t _sbrk_r(struct _reent *r, int size)
  30:../src/syscalls.c **** * 	int _stat_r(struct _reent *r, const char *pathname, struct stat *st)
  31:../src/syscalls.c **** * 	int _times_r(struct _reent *r, struct tms *buf)
  32:../src/syscalls.c **** * 	int _unlink_r(struct _reent *r, const char *pathname)
  33:../src/syscalls.c **** * 	pid_t _wait_r(struct _reent *r, int *stat_loc)
  34:../src/syscalls.c **** * 	ssize_t _write_r(struct _reent *r, int file, const void *buf, size_t nbyte)
  35:../src/syscalls.c **** *
  36:../src/syscalls.c **** * available local functions:
  37:../src/syscalls.c **** *
  38:../src/syscalls.c **** * available interrupt handlers:
  39:../src/syscalls.c **** ******************************************************************************/
  40:../src/syscalls.c **** 
  41:../src/syscalls.c **** #ifdef __cplusplus
  42:../src/syscalls.c **** extern "C" {
  43:../src/syscalls.c **** #endif
  44:../src/syscalls.c **** 
  45:../src/syscalls.c **** /*
  46:../src/syscalls.c **** +=============================================================================+
  47:../src/syscalls.c **** | configuration
  48:../src/syscalls.c **** +=============================================================================+
  49:../src/syscalls.c **** */
  50:../src/syscalls.c **** 
  51:../src/syscalls.c **** #define SYSCALLS_HAVE_CLOSE_R		1
  52:../src/syscalls.c **** #define SYSCALLS_HAVE_EXECVE_R		1
  53:../src/syscalls.c **** #define SYSCALLS_HAVE_EXIT			1
  54:../src/syscalls.c **** #define SYSCALLS_HAVE_FORK_R		1
  55:../src/syscalls.c **** #define SYSCALLS_HAVE_FSTAT_R		1
  56:../src/syscalls.c **** #define SYSCALLS_HAVE_GETPID_R		1
  57:../src/syscalls.c **** #define SYSCALLS_HAVE_ISATTY_R		1
  58:../src/syscalls.c **** #define SYSCALLS_HAVE_KILL_R		1
  59:../src/syscalls.c **** #define SYSCALLS_HAVE_LINK_R		1
  60:../src/syscalls.c **** #define SYSCALLS_HAVE_LSEEK_R		1
  61:../src/syscalls.c **** #define SYSCALLS_HAVE_OPEN_R		1
  62:../src/syscalls.c **** #define SYSCALLS_HAVE_READ_R		1
  63:../src/syscalls.c **** #define SYSCALLS_HAVE_SBRK_R		1
  64:../src/syscalls.c **** #define SYSCALLS_HAVE_STAT_R		1
  65:../src/syscalls.c **** #define SYSCALLS_HAVE_TIMES_R		1
  66:../src/syscalls.c **** #define SYSCALLS_HAVE_UNLINK_R		1
  67:../src/syscalls.c **** #define SYSCALLS_HAVE_WAIT_R		1
  68:../src/syscalls.c **** #define SYSCALLS_HAVE_WRITE_R		1
  69:../src/syscalls.c **** 
  70:../src/syscalls.c **** /*
  71:../src/syscalls.c **** +=============================================================================+
  72:../src/syscalls.c **** | includes
  73:../src/syscalls.c **** +=============================================================================+
  74:../src/syscalls.c **** */
  75:../src/syscalls.c **** 
  76:../src/syscalls.c **** #include <errno.h>
  77:../src/syscalls.c **** #include <sys/types.h>
  78:../src/syscalls.c **** #include <sys/stat.h>
  79:../src/syscalls.c **** #include <sys/times.h>
  80:../src/syscalls.c **** 
  81:../src/syscalls.c **** /*
  82:../src/syscalls.c **** +=============================================================================+
  83:../src/syscalls.c **** | module variables
  84:../src/syscalls.c **** +=============================================================================+
  85:../src/syscalls.c **** */
  86:../src/syscalls.c **** 
  87:../src/syscalls.c **** char *environ_initial[1] = {0};
  88:../src/syscalls.c **** char **environ = environ_initial;
  89:../src/syscalls.c **** 
  90:../src/syscalls.c **** #undef errno
  91:../src/syscalls.c **** extern int errno;
  92:../src/syscalls.c **** 
  93:../src/syscalls.c **** /*
  94:../src/syscalls.c **** +=============================================================================+
  95:../src/syscalls.c **** | local functions' declarations
  96:../src/syscalls.c **** +=============================================================================+
  97:../src/syscalls.c **** */
  98:../src/syscalls.c **** 
  99:../src/syscalls.c **** /*
 100:../src/syscalls.c **** +=============================================================================+
 101:../src/syscalls.c **** | global functions
 102:../src/syscalls.c **** +=============================================================================+
 103:../src/syscalls.c **** */
 104:../src/syscalls.c **** 
 105:../src/syscalls.c **** #if SYSCALLS_HAVE_CLOSE_R == 1
 106:../src/syscalls.c **** 
 107:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 108:../src/syscalls.c **** * \brief Close a file.
 109:../src/syscalls.c **** * \details Close a file.
 110:../src/syscalls.c **** *
 111:../src/syscalls.c **** * \param [in] file indicates the file descriptor to close.
 112:../src/syscalls.c **** * \return -1 for failure.
 113:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 114:../src/syscalls.c **** 
 115:../src/syscalls.c **** int _close_r(struct _reent *r, int file)
 116:../src/syscalls.c **** {
 2355              		.loc 1 116 0
 2356              		.cfi_startproc
 2357              		@ args = 0, pretend = 0, frame = 0
 2358              		@ frame_needed = 0, uses_anonymous_args = 0
 2359              		@ link register save eliminated.
 2360              	.LVL0:
 117:../src/syscalls.c **** 	r = r;									// suppress warning
 118:../src/syscalls.c **** 	file = file;							// suppress warning
 119:../src/syscalls.c **** 
 120:../src/syscalls.c **** 	return -1;
 121:../src/syscalls.c **** }
 2361              		.loc 1 121 0
 2362 0000 4FF0FF30 		mov	r0, #-1
 2363 0004 7047     		bx	lr
 2364              		.cfi_endproc
 2365              	.LFE0:
 2367              		.section	.text._execve_r,"ax",%progbits
 2368              		.align	1
 2369              		.global	_execve_r
 2370              		.thumb
 2371              		.thumb_func
 2373              	_execve_r:
 2374              	.LFB1:
 122:../src/syscalls.c **** 
 123:../src/syscalls.c **** #endif
 124:../src/syscalls.c **** 
 125:../src/syscalls.c **** #if SYSCALLS_HAVE_EXECVE_R == 1
 126:../src/syscalls.c **** 
 127:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 128:../src/syscalls.c **** * \brief Transfer control to a new process.
 129:../src/syscalls.c **** * \details Transfer control to a new process.
 130:../src/syscalls.c **** *
 131:../src/syscalls.c **** * \param [in] path specifies the path name of the new process image file.
 132:../src/syscalls.c **** * \param [in] argv is the argument list for the new process image. This should
 133:../src/syscalls.c **** * contain an array of pointers to character strings, and the array should be
 134:../src/syscalls.c **** * terminated by a NULL pointer. The value in argv[0] should point to a file
 135:../src/syscalls.c **** * name that is associated with the process being started by the exec()
 136:../src/syscalls.c **** * function.
 137:../src/syscalls.c **** * \param [in] envp specifies the environment for the new process image. This
 138:../src/syscalls.c **** * should contain an array of pointers to character strings, and the array
 139:../src/syscalls.c **** * should be terminated by a NULL pointer.
 140:../src/syscalls.c **** * \return -1 for failure.
 141:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 142:../src/syscalls.c **** 
 143:../src/syscalls.c **** int _execve_r(struct _reent *r, const char *path, char *const argv[], char *const envp[])
 144:../src/syscalls.c **** {
 2375              		.loc 1 144 0
 2376              		.cfi_startproc
 2377              		@ args = 0, pretend = 0, frame = 0
 2378              		@ frame_needed = 0, uses_anonymous_args = 0
 2379              		@ link register save eliminated.
 2380              	.LVL1:
 145:../src/syscalls.c **** 	r = r;									// suppress warning
 146:../src/syscalls.c **** 	path = path;							// suppress warning
 147:../src/syscalls.c **** 	argv = argv;							// suppress warning
 148:../src/syscalls.c **** 	envp = envp;							// suppress warning
 149:../src/syscalls.c **** 
 150:../src/syscalls.c **** 	errno = ENOMEM;
 2381              		.loc 1 150 0
 2382 0000 024B     		ldr	r3, .L3
 2383 0002 0C22     		movs	r2, #12
 2384 0004 1A60     		str	r2, [r3, #0]
 151:../src/syscalls.c **** 	return -1;
 152:../src/syscalls.c **** }
 2385              		.loc 1 152 0
 2386 0006 4FF0FF30 		mov	r0, #-1
 2387 000a 7047     		bx	lr
 2388              	.L4:
 2389              		.align	2
 2390              	.L3:
 2391 000c 00000000 		.word	errno
 2392              		.cfi_endproc
 2393              	.LFE1:
 2395              		.section	.text._exit,"ax",%progbits
 2396              		.align	1
 2397              		.global	_exit
 2398              		.thumb
 2399              		.thumb_func
 2401              	_exit:
 2402              	.LFB2:
 153:../src/syscalls.c **** 
 154:../src/syscalls.c **** #endif
 155:../src/syscalls.c **** 
 156:../src/syscalls.c **** #if SYSCALLS_HAVE_EXIT == 1
 157:../src/syscalls.c **** 
 158:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 159:../src/syscalls.c **** * \brief Exit a program.
 160:../src/syscalls.c **** * \details Exit a program without cleaning up files.
 161:../src/syscalls.c **** *
 162:../src/syscalls.c **** * \param [in] status represents the termination status.
 163:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 164:../src/syscalls.c **** 
 165:../src/syscalls.c **** void _exit(int status)
 166:../src/syscalls.c **** {
 2403              		.loc 1 166 0
 2404              		.cfi_startproc
 2405              		@ Volatile: function does not return.
 2406              		@ args = 0, pretend = 0, frame = 0
 2407              		@ frame_needed = 0, uses_anonymous_args = 0
 2408              		@ link register save eliminated.
 2409              	.LVL2:
 2410              	.L6:
 2411 0000 FEE7     		b	.L6
 2412              		.cfi_endproc
 2413              	.LFE2:
 2415              		.section	.text._fork_r,"ax",%progbits
 2416              		.align	1
 2417              		.global	_fork_r
 2418              		.thumb
 2419              		.thumb_func
 2421              	_fork_r:
 2422              	.LFB3:
 167:../src/syscalls.c **** 	status = status;						// suppress warning
 168:../src/syscalls.c **** 
 169:../src/syscalls.c **** 	while (1);
 170:../src/syscalls.c **** }
 171:../src/syscalls.c **** 
 172:../src/syscalls.c **** #endif
 173:../src/syscalls.c **** 
 174:../src/syscalls.c **** #if SYSCALLS_HAVE_FORK_R == 1
 175:../src/syscalls.c **** 
 176:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 177:../src/syscalls.c **** * \brief Create a new process.
 178:../src/syscalls.c **** * \details Create a new process.
 179:../src/syscalls.c **** *
 180:../src/syscalls.c **** * \return -1 for failure.
 181:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 182:../src/syscalls.c **** 
 183:../src/syscalls.c **** pid_t _fork_r(struct _reent *r)
 184:../src/syscalls.c **** {
 2423              		.loc 1 184 0
 2424              		.cfi_startproc
 2425              		@ args = 0, pretend = 0, frame = 0
 2426              		@ frame_needed = 0, uses_anonymous_args = 0
 2427              		@ link register save eliminated.
 2428              	.LVL3:
 185:../src/syscalls.c **** 	r = r;									// suppress warning
 186:../src/syscalls.c **** 
 187:../src/syscalls.c **** 	errno = EAGAIN;
 2429              		.loc 1 187 0
 2430 0000 024B     		ldr	r3, .L8
 2431 0002 0B22     		movs	r2, #11
 2432 0004 1A60     		str	r2, [r3, #0]
 188:../src/syscalls.c **** 	return -1;
 189:../src/syscalls.c **** }
 2433              		.loc 1 189 0
 2434 0006 4FF0FF30 		mov	r0, #-1
 2435 000a 7047     		bx	lr
 2436              	.L9:
 2437              		.align	2
 2438              	.L8:
 2439 000c 00000000 		.word	errno
 2440              		.cfi_endproc
 2441              	.LFE3:
 2443              		.section	.text._fstat_r,"ax",%progbits
 2444              		.align	1
 2445              		.global	_fstat_r
 2446              		.thumb
 2447              		.thumb_func
 2449              	_fstat_r:
 2450              	.LFB4:
 190:../src/syscalls.c **** 
 191:../src/syscalls.c **** #endif
 192:../src/syscalls.c **** 
 193:../src/syscalls.c **** #if SYSCALLS_HAVE_FSTAT_R == 1
 194:../src/syscalls.c **** 
 195:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 196:../src/syscalls.c **** * \brief Status of an open file.
 197:../src/syscalls.c **** * \details Status of an open file.
 198:../src/syscalls.c **** *
 199:../src/syscalls.c **** * \param [in] file is a file descriptor referring to a file for which status is
 200:../src/syscalls.c **** * returned.
 201:../src/syscalls.c **** * \param [out] st points to a stat structure where status information about the
 202:../src/syscalls.c **** * file is to be placed.
 203:../src/syscalls.c **** * \return 0 for success.
 204:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 205:../src/syscalls.c **** 
 206:../src/syscalls.c **** int _fstat_r(struct _reent *r, int file, struct stat *st)
 207:../src/syscalls.c **** {
 2451              		.loc 1 207 0
 2452              		.cfi_startproc
 2453              		@ args = 0, pretend = 0, frame = 0
 2454              		@ frame_needed = 0, uses_anonymous_args = 0
 2455              		@ link register save eliminated.
 2456              	.LVL4:
 208:../src/syscalls.c **** 	r = r;									// suppress warning
 209:../src/syscalls.c **** 	file = file;							// suppress warning
 210:../src/syscalls.c **** 	st = st;								// suppress warning
 211:../src/syscalls.c **** 
 212:../src/syscalls.c **** 	st->st_mode = S_IFCHR;
 2457              		.loc 1 212 0
 2458 0000 4FF40053 		mov	r3, #8192
 2459 0004 5360     		str	r3, [r2, #4]
 213:../src/syscalls.c **** 	return 0;
 214:../src/syscalls.c **** }
 2460              		.loc 1 214 0
 2461 0006 0020     		movs	r0, #0
 2462 0008 7047     		bx	lr
 2463              		.cfi_endproc
 2464              	.LFE4:
 2466              		.section	.text._getpid_r,"ax",%progbits
 2467              		.align	1
 2468              		.global	_getpid_r
 2469              		.thumb
 2470              		.thumb_func
 2472              	_getpid_r:
 2473              	.LFB5:
 215:../src/syscalls.c **** 
 216:../src/syscalls.c **** #endif
 217:../src/syscalls.c **** 
 218:../src/syscalls.c **** #if SYSCALLS_HAVE_GETPID_R == 1
 219:../src/syscalls.c **** 
 220:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 221:../src/syscalls.c **** * \brief Get calling process ID.
 222:../src/syscalls.c **** * \details Get calling process ID.
 223:../src/syscalls.c **** *
 224:../src/syscalls.c **** * \return 1.
 225:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 226:../src/syscalls.c **** 
 227:../src/syscalls.c **** pid_t _getpid_r(struct _reent *r)
 228:../src/syscalls.c **** {
 2474              		.loc 1 228 0
 2475              		.cfi_startproc
 2476              		@ args = 0, pretend = 0, frame = 0
 2477              		@ frame_needed = 0, uses_anonymous_args = 0
 2478              		@ link register save eliminated.
 2479              	.LVL5:
 229:../src/syscalls.c **** 	r = r;									// suppress warning
 230:../src/syscalls.c **** 
 231:../src/syscalls.c **** 	return 1;
 232:../src/syscalls.c **** }
 2480              		.loc 1 232 0
 2481 0000 0120     		movs	r0, #1
 2482 0002 7047     		bx	lr
 2483              		.cfi_endproc
 2484              	.LFE5:
 2486              		.section	.text._isatty_r,"ax",%progbits
 2487              		.align	1
 2488              		.global	_isatty_r
 2489              		.thumb
 2490              		.thumb_func
 2492              	_isatty_r:
 2493              	.LFB6:
 233:../src/syscalls.c **** 
 234:../src/syscalls.c **** #endif
 235:../src/syscalls.c **** 
 236:../src/syscalls.c **** #if SYSCALLS_HAVE_ISATTY_R == 1
 237:../src/syscalls.c **** 
 238:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 239:../src/syscalls.c **** * \brief Query whether output stream is a terminal.
 240:../src/syscalls.c **** * \details Query whether output stream is a terminal.
 241:../src/syscalls.c **** *
 242:../src/syscalls.c **** * \param [in] file is the file descriptor to test.
 243:../src/syscalls.c **** * \return 1.
 244:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 245:../src/syscalls.c **** 
 246:../src/syscalls.c **** int _isatty_r(struct _reent *r, int file)
 247:../src/syscalls.c **** {
 2494              		.loc 1 247 0
 2495              		.cfi_startproc
 2496              		@ args = 0, pretend = 0, frame = 0
 2497              		@ frame_needed = 0, uses_anonymous_args = 0
 2498              		@ link register save eliminated.
 2499              	.LVL6:
 248:../src/syscalls.c **** 	r = r;									// suppress warning
 249:../src/syscalls.c **** 	file = file;							// suppress warning
 250:../src/syscalls.c **** 
 251:../src/syscalls.c **** 	return 1;
 252:../src/syscalls.c **** }
 2500              		.loc 1 252 0
 2501 0000 0120     		movs	r0, #1
 2502 0002 7047     		bx	lr
 2503              		.cfi_endproc
 2504              	.LFE6:
 2506              		.section	.text._kill_r,"ax",%progbits
 2507              		.align	1
 2508              		.global	_kill_r
 2509              		.thumb
 2510              		.thumb_func
 2512              	_kill_r:
 2513              	.LFB7:
 253:../src/syscalls.c **** 
 254:../src/syscalls.c **** #endif
 255:../src/syscalls.c **** 
 256:../src/syscalls.c **** #if SYSCALLS_HAVE_KILL_R == 1
 257:../src/syscalls.c **** 
 258:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 259:../src/syscalls.c **** * \brief Send a signal.
 260:../src/syscalls.c **** * \details Send a signal.
 261:../src/syscalls.c **** *
 262:../src/syscalls.c **** * \param [in] pid is a process ID or process group ID.
 263:../src/syscalls.c **** * \param [in] signal specifies the signal to be sent.
 264:../src/syscalls.c **** * \return -1 for failure.
 265:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 266:../src/syscalls.c **** 
 267:../src/syscalls.c **** int _kill_r(struct _reent *r, pid_t pid, int signal)
 268:../src/syscalls.c **** {
 2514              		.loc 1 268 0
 2515              		.cfi_startproc
 2516              		@ args = 0, pretend = 0, frame = 0
 2517              		@ frame_needed = 0, uses_anonymous_args = 0
 2518              		@ link register save eliminated.
 2519              	.LVL7:
 269:../src/syscalls.c **** 	r = r;									// suppress warning
 270:../src/syscalls.c **** 	pid = pid;								// suppress warning
 271:../src/syscalls.c **** 	signal = signal;						// suppress warning
 272:../src/syscalls.c **** 
 273:../src/syscalls.c **** 	errno = EINVAL;
 2520              		.loc 1 273 0
 2521 0000 024B     		ldr	r3, .L14
 2522 0002 1622     		movs	r2, #22
 2523 0004 1A60     		str	r2, [r3, #0]
 274:../src/syscalls.c **** 	return -1;
 275:../src/syscalls.c **** }
 2524              		.loc 1 275 0
 2525 0006 4FF0FF30 		mov	r0, #-1
 2526 000a 7047     		bx	lr
 2527              	.L15:
 2528              		.align	2
 2529              	.L14:
 2530 000c 00000000 		.word	errno
 2531              		.cfi_endproc
 2532              	.LFE7:
 2534              		.section	.text._link_r,"ax",%progbits
 2535              		.align	1
 2536              		.global	_link_r
 2537              		.thumb
 2538              		.thumb_func
 2540              	_link_r:
 2541              	.LFB8:
 276:../src/syscalls.c **** 
 277:../src/syscalls.c **** #endif
 278:../src/syscalls.c **** 
 279:../src/syscalls.c **** #if SYSCALLS_HAVE_LINK_R == 1
 280:../src/syscalls.c **** 
 281:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 282:../src/syscalls.c **** * \brief Establish a new name for an existing file.
 283:../src/syscalls.c **** * \details Establish a new name for an existing file.
 284:../src/syscalls.c **** *
 285:../src/syscalls.c **** * \param [in] old points to a path name that names an existing file.
 286:../src/syscalls.c **** * \param [in] new points to a path name that names the new directory entry to
 287:../src/syscalls.c **** * be created.
 288:../src/syscalls.c **** * \return -1 for failure.
 289:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 290:../src/syscalls.c **** 
 291:../src/syscalls.c **** int _link_r(struct _reent *r, const char *old, const char *new)
 292:../src/syscalls.c **** {
 2542              		.loc 1 292 0
 2543              		.cfi_startproc
 2544              		@ args = 0, pretend = 0, frame = 0
 2545              		@ frame_needed = 0, uses_anonymous_args = 0
 2546              		@ link register save eliminated.
 2547              	.LVL8:
 293:../src/syscalls.c **** 	r = r;									// suppress warning
 294:../src/syscalls.c **** 	old = old;								// suppress warning
 295:../src/syscalls.c **** 	new = new;								// suppress warning
 296:../src/syscalls.c **** 
 297:../src/syscalls.c **** 	errno = EMLINK;
 2548              		.loc 1 297 0
 2549 0000 024B     		ldr	r3, .L17
 2550 0002 1F22     		movs	r2, #31
 2551 0004 1A60     		str	r2, [r3, #0]
 298:../src/syscalls.c **** 	return -1;
 299:../src/syscalls.c **** }
 2552              		.loc 1 299 0
 2553 0006 4FF0FF30 		mov	r0, #-1
 2554 000a 7047     		bx	lr
 2555              	.L18:
 2556              		.align	2
 2557              	.L17:
 2558 000c 00000000 		.word	errno
 2559              		.cfi_endproc
 2560              	.LFE8:
 2562              		.section	.text._lseek_r,"ax",%progbits
 2563              		.align	1
 2564              		.global	_lseek_r
 2565              		.thumb
 2566              		.thumb_func
 2568              	_lseek_r:
 2569              	.LFB9:
 300:../src/syscalls.c **** 
 301:../src/syscalls.c **** #endif
 302:../src/syscalls.c **** 
 303:../src/syscalls.c **** #if SYSCALLS_HAVE_LSEEK_R == 1
 304:../src/syscalls.c **** 
 305:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 306:../src/syscalls.c **** * \brief Set position in a file.
 307:../src/syscalls.c **** * \details Set position in a file.
 308:../src/syscalls.c **** *
 309:../src/syscalls.c **** * \param [in] file is the file descriptor of an open file.
 310:../src/syscalls.c **** * \param [in] offset specifies the number of bytes to offset the file pointer
 311:../src/syscalls.c **** * from a specified file origin.
 312:../src/syscalls.c **** * \param [in] whence specifies the location from which to start seeking.
 313:../src/syscalls.c **** * \return 0 for success.
 314:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 315:../src/syscalls.c **** 
 316:../src/syscalls.c **** off_t _lseek_r(struct _reent *r, int file, off_t offset, int whence)
 317:../src/syscalls.c **** {
 2570              		.loc 1 317 0
 2571              		.cfi_startproc
 2572              		@ args = 0, pretend = 0, frame = 0
 2573              		@ frame_needed = 0, uses_anonymous_args = 0
 2574              		@ link register save eliminated.
 2575              	.LVL9:
 318:../src/syscalls.c **** 	r = r;									// suppress warning
 319:../src/syscalls.c **** 	file = file;							// suppress warning
 320:../src/syscalls.c **** 	offset = offset;						// suppress warning
 321:../src/syscalls.c **** 	whence = whence;						// suppress warning
 322:../src/syscalls.c **** 
 323:../src/syscalls.c **** 	return 0;
 324:../src/syscalls.c **** }
 2576              		.loc 1 324 0
 2577 0000 0020     		movs	r0, #0
 2578 0002 7047     		bx	lr
 2579              		.cfi_endproc
 2580              	.LFE9:
 2582              		.section	.text._open_r,"ax",%progbits
 2583              		.align	1
 2584              		.global	_open_r
 2585              		.thumb
 2586              		.thumb_func
 2588              	_open_r:
 2589              	.LFB10:
 325:../src/syscalls.c **** 
 326:../src/syscalls.c **** #endif
 327:../src/syscalls.c **** 
 328:../src/syscalls.c **** #if SYSCALLS_HAVE_OPEN_R == 1
 329:../src/syscalls.c **** 
 330:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 331:../src/syscalls.c **** * \brief Open a file.
 332:../src/syscalls.c **** * \details Open a file.
 333:../src/syscalls.c **** *
 334:../src/syscalls.c **** * \param [in] pathname is the name of the file to open.
 335:../src/syscalls.c **** * \param [in] flags is the bitwise inclusive-OR of the file access modes and
 336:../src/syscalls.c **** * file status flags.
 337:../src/syscalls.c **** * \param [in] mode specifies what permissions the file has when it is created.
 338:../src/syscalls.c **** * \return -1 for failure.
 339:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 340:../src/syscalls.c **** 
 341:../src/syscalls.c **** int _open_r(struct _reent *r, const char *pathname, int flags, int mode)
 342:../src/syscalls.c **** {
 2590              		.loc 1 342 0
 2591              		.cfi_startproc
 2592              		@ args = 0, pretend = 0, frame = 0
 2593              		@ frame_needed = 0, uses_anonymous_args = 0
 2594              		@ link register save eliminated.
 2595              	.LVL10:
 343:../src/syscalls.c **** 	r = r;									// suppress warning
 344:../src/syscalls.c **** 	pathname = pathname;					// suppress warning
 345:../src/syscalls.c **** 	flags = flags;							// suppress warning
 346:../src/syscalls.c **** 	mode = mode;							// suppress warning
 347:../src/syscalls.c **** 
 348:../src/syscalls.c **** 	return -1;
 349:../src/syscalls.c **** }
 2596              		.loc 1 349 0
 2597 0000 4FF0FF30 		mov	r0, #-1
 2598 0004 7047     		bx	lr
 2599              		.cfi_endproc
 2600              	.LFE10:
 2602              		.section	.text._read_r,"ax",%progbits
 2603              		.align	1
 2604              		.global	_read_r
 2605              		.thumb
 2606              		.thumb_func
 2608              	_read_r:
 2609              	.LFB11:
 350:../src/syscalls.c **** 
 351:../src/syscalls.c **** #endif
 352:../src/syscalls.c **** 
 353:../src/syscalls.c **** #if SYSCALLS_HAVE_READ_R == 1
 354:../src/syscalls.c **** 
 355:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 356:../src/syscalls.c **** * \brief Read from a file.
 357:../src/syscalls.c **** * \details Read from a file.
 358:../src/syscalls.c **** *
 359:../src/syscalls.c **** * \param [in] file is the file descriptor that references an open file.
 360:../src/syscalls.c **** * \param [in] buf points to the buffer to place the read information into.
 361:../src/syscalls.c **** * \param [in] nbyte specifies the maximum number of bytes to attempt to read.
 362:../src/syscalls.c **** * \return 0 for success.
 363:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 364:../src/syscalls.c **** 
 365:../src/syscalls.c **** ssize_t _read_r(struct _reent *r, int file, void *buf, size_t nbyte)
 366:../src/syscalls.c **** {
 2610              		.loc 1 366 0
 2611              		.cfi_startproc
 2612              		@ args = 0, pretend = 0, frame = 0
 2613              		@ frame_needed = 0, uses_anonymous_args = 0
 2614              		@ link register save eliminated.
 2615              	.LVL11:
 367:../src/syscalls.c **** 	r = r;									// suppress warning
 368:../src/syscalls.c **** 	file = file;							// suppress warning
 369:../src/syscalls.c **** 	buf = buf;								// suppress warning
 370:../src/syscalls.c **** 	nbyte = nbyte;							// suppress warning
 371:../src/syscalls.c **** 
 372:../src/syscalls.c **** 	return 0;
 373:../src/syscalls.c **** }
 2616              		.loc 1 373 0
 2617 0000 0020     		movs	r0, #0
 2618 0002 7047     		bx	lr
 2619              		.cfi_endproc
 2620              	.LFE11:
 2622              		.section	.text._sbrk_r,"ax",%progbits
 2623              		.align	1
 2624              		.global	_sbrk_r
 2625              		.thumb
 2626              		.thumb_func
 2628              	_sbrk_r:
 2629              	.LFB12:
 374:../src/syscalls.c **** 
 375:../src/syscalls.c **** #endif
 376:../src/syscalls.c **** 
 377:../src/syscalls.c **** #if SYSCALLS_HAVE_SBRK_R == 1
 378:../src/syscalls.c **** 
 379:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 380:../src/syscalls.c **** * \brief Increase program data space.
 381:../src/syscalls.c **** * \details Increase program data space. This version of _sbrk_r() requires the
 382:../src/syscalls.c **** * heap area to be defined explicitly in linker script with symbols __heap_start
 383:../src/syscalls.c **** * and __heap_end.
 384:../src/syscalls.c **** *
 385:../src/syscalls.c **** * \param [in] size is the requested data space size.
 386:../src/syscalls.c **** * \return pointer to new data space.
 387:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 388:../src/syscalls.c **** 
 389:../src/syscalls.c **** caddr_t _sbrk_r(struct _reent *r, int size)
 390:../src/syscalls.c **** {
 2630              		.loc 1 390 0
 2631              		.cfi_startproc
 2632              		@ args = 0, pretend = 0, frame = 0
 2633              		@ frame_needed = 0, uses_anonymous_args = 0
 2634              		@ link register save eliminated.
 2635              	.LVL12:
 391:../src/syscalls.c **** 	extern char __heap_start;				// imported from linker script
 392:../src/syscalls.c **** 	extern char __heap_end;					// imported from linker script
 393:../src/syscalls.c **** 	static char *current_heap_end = &__heap_start;
 394:../src/syscalls.c **** 	char *previous_heap_end;
 395:../src/syscalls.c **** 
 396:../src/syscalls.c **** 	r = r;									// suppress warning
 397:../src/syscalls.c **** 
 398:../src/syscalls.c **** 	previous_heap_end = current_heap_end;
 2636              		.loc 1 398 0
 2637 0000 064B     		ldr	r3, .L25
 399:../src/syscalls.c **** 
 400:../src/syscalls.c **** 	if (current_heap_end + size > &__heap_end)	// is there enough space on the heap left?
 2638              		.loc 1 400 0
 2639 0002 074A     		ldr	r2, .L25+4
 398:../src/syscalls.c **** 	previous_heap_end = current_heap_end;
 2640              		.loc 1 398 0
 2641 0004 1868     		ldr	r0, [r3, #0]
 2642              	.LVL13:
 2643              		.loc 1 400 0
 2644 0006 4118     		adds	r1, r0, r1
 2645              	.LVL14:
 2646 0008 9142     		cmp	r1, r2
 2647 000a 05D9     		bls	.L23
 401:../src/syscalls.c **** 	{
 402:../src/syscalls.c **** 		errno = ENOMEM;						// not enough memory left
 2648              		.loc 1 402 0
 2649 000c 054B     		ldr	r3, .L25+8
 2650 000e 0C22     		movs	r2, #12
 2651 0010 1A60     		str	r2, [r3, #0]
 403:../src/syscalls.c **** 		return (caddr_t) -1;				// return immediatelly
 2652              		.loc 1 403 0
 2653 0012 4FF0FF30 		mov	r0, #-1
 2654 0016 7047     		bx	lr
 2655              	.L23:
 404:../src/syscalls.c **** 	}
 405:../src/syscalls.c **** 
 406:../src/syscalls.c **** 	current_heap_end += size;				// increase data space
 2656              		.loc 1 406 0
 2657 0018 1960     		str	r1, [r3, #0]
 407:../src/syscalls.c **** 
 408:../src/syscalls.c **** 	return (caddr_t)previous_heap_end;		// return requested data space
 409:../src/syscalls.c **** }
 2658              		.loc 1 409 0
 2659 001a 7047     		bx	lr
 2660              	.L26:
 2661              		.align	2
 2662              	.L25:
 2663 001c 00000000 		.word	.LANCHOR0
 2664 0020 00000000 		.word	__heap_end
 2665 0024 00000000 		.word	errno
 2666              		.cfi_endproc
 2667              	.LFE12:
 2669              		.section	.text._stat_r,"ax",%progbits
 2670              		.align	1
 2671              		.global	_stat_r
 2672              		.thumb
 2673              		.thumb_func
 2675              	_stat_r:
 2676              	.LFB13:
 410:../src/syscalls.c **** 
 411:../src/syscalls.c **** #endif
 412:../src/syscalls.c **** 
 413:../src/syscalls.c **** #if SYSCALLS_HAVE_STAT_R == 1
 414:../src/syscalls.c **** 
 415:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 416:../src/syscalls.c **** * \brief Status of a file (by name).
 417:../src/syscalls.c **** * \details Status of a file (by name).
 418:../src/syscalls.c **** *
 419:../src/syscalls.c **** * \param [in] pathname pPoints to a path name that names a file.
 420:../src/syscalls.c **** * \param [out] st points to a stat structure where status information about the
 421:../src/syscalls.c **** * file is to be placed.
 422:../src/syscalls.c **** * \return 0 for success.
 423:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 424:../src/syscalls.c **** 
 425:../src/syscalls.c **** int _stat_r(struct _reent *r, const char *pathname, struct stat *st)
 426:../src/syscalls.c **** {
 2677              		.loc 1 426 0
 2678              		.cfi_startproc
 2679              		@ args = 0, pretend = 0, frame = 0
 2680              		@ frame_needed = 0, uses_anonymous_args = 0
 2681              		@ link register save eliminated.
 2682              	.LVL15:
 427:../src/syscalls.c **** 	r = r;									// suppress warning
 428:../src/syscalls.c **** 	pathname = pathname;					// suppress warning
 429:../src/syscalls.c **** 
 430:../src/syscalls.c **** 	st->st_mode = S_IFCHR;
 2683              		.loc 1 430 0
 2684 0000 4FF40053 		mov	r3, #8192
 2685 0004 5360     		str	r3, [r2, #4]
 431:../src/syscalls.c **** 	return 0;
 432:../src/syscalls.c **** }
 2686              		.loc 1 432 0
 2687 0006 0020     		movs	r0, #0
 2688 0008 7047     		bx	lr
 2689              		.cfi_endproc
 2690              	.LFE13:
 2692              		.section	.text._times_r,"ax",%progbits
 2693              		.align	1
 2694              		.global	_times_r
 2695              		.thumb
 2696              		.thumb_func
 2698              	_times_r:
 2699              	.LFB14:
 433:../src/syscalls.c **** 
 434:../src/syscalls.c **** #endif
 435:../src/syscalls.c **** 
 436:../src/syscalls.c **** #if SYSCALLS_HAVE_TIMES_R == 1
 437:../src/syscalls.c **** 
 438:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 439:../src/syscalls.c **** * \brief Timing information for current process.
 440:../src/syscalls.c **** * \details Timing information for current process.
 441:../src/syscalls.c **** *
 442:../src/syscalls.c **** * \param [out] buf points to a tms structure where timing information about the
 443:../src/syscalls.c **** * process is to be placed.
 444:../src/syscalls.c **** * \return -1 for failure.
 445:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 446:../src/syscalls.c **** 
 447:../src/syscalls.c **** int _times_r(struct _reent *r, struct tms *buf)
 448:../src/syscalls.c **** {
 2700              		.loc 1 448 0
 2701              		.cfi_startproc
 2702              		@ args = 0, pretend = 0, frame = 0
 2703              		@ frame_needed = 0, uses_anonymous_args = 0
 2704              		@ link register save eliminated.
 2705              	.LVL16:
 449:../src/syscalls.c **** 	r = r;									// suppress warning
 450:../src/syscalls.c **** 	buf = buf;								// suppress warning
 451:../src/syscalls.c **** 
 452:../src/syscalls.c **** 	return -1;
 453:../src/syscalls.c **** }
 2706              		.loc 1 453 0
 2707 0000 4FF0FF30 		mov	r0, #-1
 2708 0004 7047     		bx	lr
 2709              		.cfi_endproc
 2710              	.LFE14:
 2712              		.section	.text._unlink_r,"ax",%progbits
 2713              		.align	1
 2714              		.global	_unlink_r
 2715              		.thumb
 2716              		.thumb_func
 2718              	_unlink_r:
 2719              	.LFB15:
 454:../src/syscalls.c **** 
 455:../src/syscalls.c **** #endif
 456:../src/syscalls.c **** 
 457:../src/syscalls.c **** #if SYSCALLS_HAVE_UNLINK_R == 1
 458:../src/syscalls.c **** 
 459:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 460:../src/syscalls.c **** * \brief Remove a file’s directory entry.
 461:../src/syscalls.c **** * \details Remove a file’s directory entry.
 462:../src/syscalls.c **** *
 463:../src/syscalls.c **** * \param [in] pathname points to the path name that names the file to be
 464:../src/syscalls.c **** * unlinked.
 465:../src/syscalls.c **** * \return -1 for failure.
 466:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 467:../src/syscalls.c **** 
 468:../src/syscalls.c **** int _unlink_r(struct _reent *r, const char *pathname)
 469:../src/syscalls.c **** {
 2720              		.loc 1 469 0
 2721              		.cfi_startproc
 2722              		@ args = 0, pretend = 0, frame = 0
 2723              		@ frame_needed = 0, uses_anonymous_args = 0
 2724              		@ link register save eliminated.
 2725              	.LVL17:
 470:../src/syscalls.c **** 	r = r;									// suppress warning
 471:../src/syscalls.c **** 	pathname = pathname;					// suppress warning
 472:../src/syscalls.c **** 
 473:../src/syscalls.c **** 	errno = ENOENT;
 2726              		.loc 1 473 0
 2727 0000 024B     		ldr	r3, .L30
 2728 0002 0222     		movs	r2, #2
 2729 0004 1A60     		str	r2, [r3, #0]
 474:../src/syscalls.c **** 	return -1;
 475:../src/syscalls.c **** }
 2730              		.loc 1 475 0
 2731 0006 4FF0FF30 		mov	r0, #-1
 2732 000a 7047     		bx	lr
 2733              	.L31:
 2734              		.align	2
 2735              	.L30:
 2736 000c 00000000 		.word	errno
 2737              		.cfi_endproc
 2738              	.LFE15:
 2740              		.section	.text._wait_r,"ax",%progbits
 2741              		.align	1
 2742              		.global	_wait_r
 2743              		.thumb
 2744              		.thumb_func
 2746              	_wait_r:
 2747              	.LFB16:
 476:../src/syscalls.c **** 
 477:../src/syscalls.c **** #endif
 478:../src/syscalls.c **** 
 479:../src/syscalls.c **** #if SYSCALLS_HAVE_WAIT_R == 1
 480:../src/syscalls.c **** 
 481:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 482:../src/syscalls.c **** * \brief Wait for a child process.
 483:../src/syscalls.c **** * \details Wait for a child process.
 484:../src/syscalls.c **** *
 485:../src/syscalls.c **** * \param [in,out] stat_loc specifies the location where the child process' exit
 486:../src/syscalls.c **** * status is stored.
 487:../src/syscalls.c **** * \return -1 for failure.
 488:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 489:../src/syscalls.c **** 
 490:../src/syscalls.c **** pid_t _wait_r(struct _reent *r, int *stat_loc)
 491:../src/syscalls.c **** {
 2748              		.loc 1 491 0
 2749              		.cfi_startproc
 2750              		@ args = 0, pretend = 0, frame = 0
 2751              		@ frame_needed = 0, uses_anonymous_args = 0
 2752              		@ link register save eliminated.
 2753              	.LVL18:
 492:../src/syscalls.c **** 	r = r;									// suppress warning
 493:../src/syscalls.c **** 	stat_loc = stat_loc;					// suppress warning
 494:../src/syscalls.c **** 
 495:../src/syscalls.c **** 	errno = ECHILD;
 2754              		.loc 1 495 0
 2755 0000 024B     		ldr	r3, .L33
 2756 0002 0A22     		movs	r2, #10
 2757 0004 1A60     		str	r2, [r3, #0]
 496:../src/syscalls.c **** 	return -1;
 497:../src/syscalls.c **** }
 2758              		.loc 1 497 0
 2759 0006 4FF0FF30 		mov	r0, #-1
 2760 000a 7047     		bx	lr
 2761              	.L34:
 2762              		.align	2
 2763              	.L33:
 2764 000c 00000000 		.word	errno
 2765              		.cfi_endproc
 2766              	.LFE16:
 2768              		.section	.text._write_r,"ax",%progbits
 2769              		.align	1
 2770              		.global	_write_r
 2771              		.thumb
 2772              		.thumb_func
 2774              	_write_r:
 2775              	.LFB17:
 498:../src/syscalls.c **** 
 499:../src/syscalls.c **** #endif
 500:../src/syscalls.c **** 
 501:../src/syscalls.c **** #if SYSCALLS_HAVE_WRITE_R == 1
 502:../src/syscalls.c **** 
 503:../src/syscalls.c **** /*------------------------------------------------------------------------*//**
 504:../src/syscalls.c **** * \brief Wait for a child process.
 505:../src/syscalls.c **** * \details Wait for a child process.
 506:../src/syscalls.c **** *
 507:../src/syscalls.c **** * \param [in] file is the file descriptor of an open file to write to.
 508:../src/syscalls.c **** * \param [in] buf is an array of data to write to the open file.
 509:../src/syscalls.c **** * \param [in] nbyte is the number of bytes to write to the file.
 510:../src/syscalls.c **** * \return 0 for success.
 511:../src/syscalls.c **** *//*-------------------------------------------------------------------------*/
 512:../src/syscalls.c **** 
 513:../src/syscalls.c **** ssize_t _write_r(struct _reent *r, int file, const void *buf, size_t nbyte)
 514:../src/syscalls.c **** {
 2776              		.loc 1 514 0
 2777              		.cfi_startproc
 2778              		@ args = 0, pretend = 0, frame = 0
 2779              		@ frame_needed = 0, uses_anonymous_args = 0
 2780              		@ link register save eliminated.
 2781              	.LVL19:
 515:../src/syscalls.c **** 	r = r;									// suppress warning
 516:../src/syscalls.c **** 	file = file;							// suppress warning
 517:../src/syscalls.c **** 	buf = buf;								// suppress warning
 518:../src/syscalls.c **** 	nbyte = nbyte;							// suppress warning
 519:../src/syscalls.c **** 
 520:../src/syscalls.c **** 	return 0;
 521:../src/syscalls.c **** }
 2782              		.loc 1 521 0
 2783 0000 0020     		movs	r0, #0
 2784 0002 7047     		bx	lr
 2785              		.cfi_endproc
 2786              	.LFE17:
 2788              		.global	environ_initial
 2789              		.global	environ
 2790              		.section	.data.environ,"aw",%progbits
 2791              		.align	2
 2794              	environ:
 2795 0000 00000000 		.word	environ_initial
 2796              		.section	.bss.environ_initial,"aw",%nobits
 2797              		.align	2
 2800              	environ_initial:
 2801 0000 00000000 		.space	4
 2802              		.section	.data.current_heap_end.4326,"aw",%progbits
 2803              		.align	2
 2804              		.set	.LANCHOR0,. + 0
 2807              	current_heap_end.4326:
 2808 0000 00000000 		.word	__heap_start
 2809              		.text
 2810              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 syscalls.c
     /tmp/ccCzjhOH.s:2348   .text._close_r:00000000 $t
     /tmp/ccCzjhOH.s:2353   .text._close_r:00000000 _close_r
     /tmp/ccCzjhOH.s:2368   .text._execve_r:00000000 $t
     /tmp/ccCzjhOH.s:2373   .text._execve_r:00000000 _execve_r
     /tmp/ccCzjhOH.s:2391   .text._execve_r:0000000c $d
     /tmp/ccCzjhOH.s:2396   .text._exit:00000000 $t
     /tmp/ccCzjhOH.s:2401   .text._exit:00000000 _exit
     /tmp/ccCzjhOH.s:2416   .text._fork_r:00000000 $t
     /tmp/ccCzjhOH.s:2421   .text._fork_r:00000000 _fork_r
     /tmp/ccCzjhOH.s:2439   .text._fork_r:0000000c $d
     /tmp/ccCzjhOH.s:2444   .text._fstat_r:00000000 $t
     /tmp/ccCzjhOH.s:2449   .text._fstat_r:00000000 _fstat_r
     /tmp/ccCzjhOH.s:2467   .text._getpid_r:00000000 $t
     /tmp/ccCzjhOH.s:2472   .text._getpid_r:00000000 _getpid_r
     /tmp/ccCzjhOH.s:2487   .text._isatty_r:00000000 $t
     /tmp/ccCzjhOH.s:2492   .text._isatty_r:00000000 _isatty_r
     /tmp/ccCzjhOH.s:2507   .text._kill_r:00000000 $t
     /tmp/ccCzjhOH.s:2512   .text._kill_r:00000000 _kill_r
     /tmp/ccCzjhOH.s:2530   .text._kill_r:0000000c $d
     /tmp/ccCzjhOH.s:2535   .text._link_r:00000000 $t
     /tmp/ccCzjhOH.s:2540   .text._link_r:00000000 _link_r
     /tmp/ccCzjhOH.s:2558   .text._link_r:0000000c $d
     /tmp/ccCzjhOH.s:2563   .text._lseek_r:00000000 $t
     /tmp/ccCzjhOH.s:2568   .text._lseek_r:00000000 _lseek_r
     /tmp/ccCzjhOH.s:2583   .text._open_r:00000000 $t
     /tmp/ccCzjhOH.s:2588   .text._open_r:00000000 _open_r
     /tmp/ccCzjhOH.s:2603   .text._read_r:00000000 $t
     /tmp/ccCzjhOH.s:2608   .text._read_r:00000000 _read_r
     /tmp/ccCzjhOH.s:2623   .text._sbrk_r:00000000 $t
     /tmp/ccCzjhOH.s:2628   .text._sbrk_r:00000000 _sbrk_r
     /tmp/ccCzjhOH.s:2663   .text._sbrk_r:0000001c $d
     /tmp/ccCzjhOH.s:2670   .text._stat_r:00000000 $t
     /tmp/ccCzjhOH.s:2675   .text._stat_r:00000000 _stat_r
     /tmp/ccCzjhOH.s:2693   .text._times_r:00000000 $t
     /tmp/ccCzjhOH.s:2698   .text._times_r:00000000 _times_r
     /tmp/ccCzjhOH.s:2713   .text._unlink_r:00000000 $t
     /tmp/ccCzjhOH.s:2718   .text._unlink_r:00000000 _unlink_r
     /tmp/ccCzjhOH.s:2736   .text._unlink_r:0000000c $d
     /tmp/ccCzjhOH.s:2741   .text._wait_r:00000000 $t
     /tmp/ccCzjhOH.s:2746   .text._wait_r:00000000 _wait_r
     /tmp/ccCzjhOH.s:2764   .text._wait_r:0000000c $d
     /tmp/ccCzjhOH.s:2769   .text._write_r:00000000 $t
     /tmp/ccCzjhOH.s:2774   .text._write_r:00000000 _write_r
     /tmp/ccCzjhOH.s:2800   .bss.environ_initial:00000000 environ_initial
     /tmp/ccCzjhOH.s:2794   .data.environ:00000000 environ
     /tmp/ccCzjhOH.s:2791   .data.environ:00000000 $d
     /tmp/ccCzjhOH.s:2797   .bss.environ_initial:00000000 $d
     /tmp/ccCzjhOH.s:2803   .data.current_heap_end.4326:00000000 $d
     /tmp/ccCzjhOH.s:2807   .data.current_heap_end.4326:00000000 current_heap_end.4326
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
errno
__heap_end
__heap_start
